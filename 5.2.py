import numpy as np

# =====================================
# 1. Вхідні дані (таблиця 5.4)
# =====================================
data = np.array([
    [71.2, 54.7, 128, 38995, 10.43, 412.8, 3436, 101.6, 21.0, 17.9, 287],
    [71.6, 55.56, 120.1, 13636, 14.92, 452.7, 3899, 130.408, 19.0, 18.26, 282.56],
    [74.25, 55.49, 114.4, 12905, 12.11, 410.2, 4644, 101.306, 18.0, 18.71, 281.05],
    [74.25, 56.12, 113.9, 13271, 18.67, 458.6, 2051, 141.993, 26.0, 19.69, 283.68],
    [78.38, 61.78, 116.8, 26785, 56.83, 518.6, 2562, 385.409, 36.0, 20.19, 299.65],
    [82.2, 64.22, 115.3, 30437, 80.62, 555.9, 2855, 482.03, 15.3, 20.42, 307.13],
    [84.28, 65.32, 120.1, 42156, 18.65, 458.6, 2855, 141.932, 16.25, 20.89, 316.85],
    [86.08, 68.48, 121.0, 12936, 34.30, 483.1, 2891, 222.11, 17.64, 20.90, 324.33],
    [87.94, 71.8, 125.8, 23894, 41.60, 494.6, 3512, 274.297, 19.23, 21.48, 336.90],
    [89.43, 74.24, 127.8, 25355, 34.31, 483.2, 1251, 222.196, 19.74, 21.53, 343.80],
    [104.6, 98.9, 147.9, 38759, 28.2, 473.6, 3299, 185.061, 26.45, 26.83, 421.71]
])

# =====================================
# 2. Розділення на входи та вихід
# =====================================
X = data[:, :-1]   # X1 ... X10
y = data[:, -1]    # Y

# =====================================
# 3. Вибілювання входів
# =====================================
mean_X = np.mean(X, axis=0)
X_centered = X - mean_X

cov_X = np.cov(X_centered, rowvar=False)

eig_val, eig_vec = np.linalg.eigh(cov_X)

W = eig_vec @ np.diag(1.0 / np.sqrt(eig_val))
X_white = X_centered @ W

# =====================================
# 4. Перевірка коректності вибілювання
# =====================================
print("Кореляційна матриця після вибілювання:")
print(np.round(np.corrcoef(X_white, rowvar=False), 3))

print("\nДисперсії після вибілювання:")
print(np.round(np.var(X_white, axis=0), 3))

# =====================================
# 5. Зворотне перетворення
# =====================================
X_restore = X_white @ np.diag(np.sqrt(eig_val)) @ eig_vec.T + mean_X
max_error = np.max(np.abs(X - X_restore))

print("\nМаксимальна похибка зворотного перетворення:")
print(max_error)

# =====================================
# 6. Ідентифікація залежності
#    Лінійний нейрон (МНК)
# =====================================
def linear_neuron_mse(Xm, y):
    X1 = np.column_stack([np.ones(len(Xm)), Xm])
    w = np.linalg.lstsq(X1, y, rcond=None)[0]
    y_hat = X1 @ w
    return np.mean((y - y_hat) ** 2)

mse_raw = linear_neuron_mse(X, y)
mse_white = linear_neuron_mse(X_white, y)

print("\nMSE без вибілювання:", mse_raw)
print("MSE з вибілюванням:", mse_white)
